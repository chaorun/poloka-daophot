include $(CMTROOT)/src/Makefile.header

include $(CMTROOT)/src/constituents.make

#### "alltelinst" and "root_dict" targets are part of toadslib_dependencies.

######### alltelinst stuff ############################

alltelinst : $(src)alltelinst.cc  $(src)alltelinst.h
	@echo  '----> alltelinst stuff OK <-----'

##### the actual makefile is located at the end of $(src)fitstoad.cc,
##### (within ifdef endif) since it generates code to be included in this file.
##### the awk statement extracts the makefile and pipes it into "make"
## the dependency list reads as follows :
##  - the cc files are grepped to produce the target
##  - the directory because adding or removing a files updates it
##  - fitstoad.cc contains the actual makefile that generates the targets

$(src)alltelinst.cc $(src)alltelinst.h : ../telinst/*.cc ../telinst $(src)fitstoad.cc
	@ cd $(src); \
	awk '{if (switch) print $$0}/FOR_MAKE/{switch=1}/^#endif/{if (switch) switch=0}' fitstoad.cc | $(MAKE) -f - `basename $@`
	@echo "--> generated $@ <---"



alltelinstclean :
	rm -f $(src)alltelinst.cc $(src)alltelinst.h 

toadslibclean :: alltelinstclean 

#######################################################################
###### root "dictionary " #################

ifdef use_root
root_dict_dir = $(src)root_dict/

# the .cc files that require a rootcint run
containing_linkdefs = $(shell grep -l  RUN_ROOTCINT $(src)*.cc)

#the linkdef files (Extracted by grep from the previous ones)
corresponding_linkdefs = $(patsubst $(src)%.cc,\
       $(root_dict_dir)%.LinkDef.h,$(containing_linkdefs))

# the headers that rootcint has to parse
headers_to_parse = $(patsubst %.cc,%.h,$(containing_linkdefs))

# the outputs from rootcint
to_produce_by_rootcint = $(patsubst $(src)%.cc,\
         $(root_dict_dir)%dict.cc,$(containing_linkdefs))

root_dict : $(to_produce_by_rootcint) $(corresponding_linkdefs)
#	@echo $(containing_linkdefs) 
#	@echo $(corresponding_linkdefs)
#	@echo $(headers_to_parse)
#	@echo $(to_produce_by_rootcint)
	@echo "----> root dictionary stuff OK <-----"

$(root_dict_dir)%.LinkDef.h : $(src)%.cc $(root_dict_dir)LinkDef.*.h
	@rm -f $@
	@cat $(root_dict_dir)/LinkDef.head.h > $@
	@echo "/*" produced via a grep in `basename $<` "*/" >> $@
	@grep LINKDEF_CONTENT $< | sed 's/^ *LINKDEF_CONTENT : *//' >> $@
	@cat $(root_dict_dir)/LinkDef.tail.h >> $@
	@echo '-> (re)done $@ <-'

#ROOTCINT_DEFINES = -DG__NOALGORITHM

ROOTCINT_DEFINES = $(use_root) -D__NOALGORITHM
ROOTCINT_INCLUDES = -I$(src)
ROOTCINT_FLAGS = $(ROOTCINT_INCLUDES) $(ROOTCINT_DEFINES)

## $* in the rule part subsitutes to % in the 'target : dependency' part (!?)
$(root_dict_dir)%dict.cc : $(src)%.h $(src)%.cc $(root_dict_dir)%.LinkDef.h
	$(ROOTCINT) -v4 -f $@ -c $(ROOTCINT_FLAGS) $< $(root_dict_dir)$*.LinkDef.h
# the code generated by rootcint involves template arguments that prevent
# correct calculation of offsets within objects...
	sed 's^>,__malloc_alloc_template<0> >^> >^g' $@ | \
	sed 's^,__malloc_alloc_template<0> ^^g' > tmp; mv -f tmp $@
	@echo "  $@ generated by rootcint "
# transform algorithm.h  into algorithm
	@sed 's/algorithm\.h/algorithm/' $(root_dict_dir)$*dict.h > tmp;\
	 mv -f tmp $(root_dict_dir)$*dict.h


# generate dependencies of $(root_dict)%dict.cc.
# There is a trick here : the dependencies are those of $(src)%.h 
# (the one actually parsed by rootcint). 
# pp_cppflags is a macro that contains the defines (-D...) used to compile

-include dict_dependencies.make
dict_dependencies.make : $(containing_linkdefs)
	@touch $@.tmp
	@makedepend -f$@.tmp -D__cplusplus $(pp_cppflags) -Y$(src) $(headers_to_parse) -odict.cc >& /dev/null
# dict.cc was added at the end of the target by the line above.
# replace $(src)  by $(root_dict_dir) at the begining of line (i.e. target side). 
	@sed 's#^$(src)#$(root_dict_dir)#' $@.tmp > $@
	@\rm -f $@.tmp
	@echo " rebuilt $@ "

root_dictclean :
	cd $(root_dict_dir); \rm -f *dict.cc *dict.h *.LinkDef.h dict_dependencies.make

toadslibclean :: root_dictclean

else

## use_root is not defined. place a root_dict target anyway:
root_dict :
	@echo "-> no root dictionnary to generate : use_root is not defined <-"

endif


########## create links to executables in a directory ###############

public_mains = flat flatfield sky_hist make_catalog header makedbflat mkskyhist \
               matchusno make_sub newmake_sub make_mosaique \
               mariages removeback mosaique_int trim changekey makefringe defringe \
               image_combine skylev astrom

public_mains += install_image assign dbls l2tup mariages split_fits relative_ln
#                                                             one $ gets eaten by make :
public_mains := $(shell grep application requirements | grep -v '^\#' | awk '{print $$2}')

install :: all 
# all the commands have to be grouped unless make runs 
# a different process for each one which makes the test inactive.
	@if test ! "${INSTALL_DIR}" ; \
	  then echo "---------   >> to install do: setenv INSTALL_DIR (links will be put there)";exit;\
	fi;\
	for i in $(public_mains) ; do\
	  ln -fs $(TOADSBIN)/$$i.exe ${INSTALL_DIR}/$$i;\
	done ;\

# to remember how one creates a shared library on Linux
# ld -shared -o libtoadslib.so --whole-archive libtoadslib.a


#############  doc #####################

doc :
	cd ../src; doxygen
	cd ../doc/latex; make; dvips refman; cd ..; ln -s latex/refman.ps 

########### toads.so ####################
## toads .so is a very small shared library that contains 
## references to all shared libraries nedded to run toads
ifdef root

lib_for_root = $(bin)toads.so 

toadslib :: $(lib_for_root)

$(lib_for_root) : $(bin)libtoadslib.so
	g++ -shared -o $@ $(toads_linkopts) \
	$(sex_linkopts) $(cfitsio_linkopts) $(f77libs)
	@echo ' -----> $@ ok '

endif
