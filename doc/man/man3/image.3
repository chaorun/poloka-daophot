.TH "Image" 3 "8 Feb 2004" "toads" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Image \- Class for the basic manipulation of images. 
.SH SYNOPSIS
.br
.PP
\fC#include <image.h>\fR
.PP
Inherited by \fBFitsImage\fR, and \fBFitsSlice\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBImage\fR (const int Nx, const int Ny)"
.br
.RI "\fIconstructor reserves the needed space to store the pixels.\fR"
.ti -1c
.RI "\fBImage\fR ()"
.br
.RI "\fIreserves an empty image.\fR"
.ti -1c
.RI "\fBImage\fR (const Image &)"
.br
.RI "\fIcopy constructor.\fR"
.ti -1c
.RI "virtual \fB~Image\fR ()"
.br
.ti -1c
.RI "Pixel& \fBoperator()\fR (const int i, const int j)"
.br
.RI "\fIaccess to the data (RW mode). The first pixel is indexed (0,0).\fR"
.ti -1c
.RI "Pixel& \fBoperator()\fR (const int i, const int j) const"
.br
.ti -1c
.RI "Pixel& \fBvalue\fR (const int i, const int j)"
.br
.ti -1c
.RI "Pixel \fBMinValue\fR () const"
.br
.RI "\fIreturns the minimum pixel value.\fR"
.ti -1c
.RI "Pixel \fBMaxValue\fR () const"
.br
.RI "\fIreturns the maximum pixel value.\fR"
.ti -1c
.RI "void \fBMinMaxValue\fR (Pixel *Min, Pixel *Max) const"
.br
.RI "\fIreturns both min and max in a single image traversal.\fR"
.ti -1c
.RI "void \fBClippedMeanSigmaValue\fR (double &Mean, double &Sigma, Image *pmask=NULL) const"
.br
.ti -1c
.RI "Pixel \fBMedianInFrame\fR (const \fBFrame\fR &Region, Pixel &Sigma) const"
.br
.RI "\fIcomputes the median in a region of an image.\fR"
.ti -1c
.RI "void \fBEnforceMinMax\fR (Pixel min, Pixel max) const"
.br
.RI "\fIenforce the min and max value of the image.\fR"
.ti -1c
.RI "int \fBminx\fR () const"
.br
.ti -1c
.RI "int \fBmaxx\fR () const"
.br
.ti -1c
.RI "int \fBminy\fR () const"
.br
.ti -1c
.RI "int \fBmaxy\fR () const"
.br
.ti -1c
.RI "void \fBMeanSigmaValue\fR (Pixel *Mean, Pixel *Sigma) const"
.br
.RI "\fIcomputes the mean and sigma of an image using 5 loops over ALL image.\fR"
.ti -1c
.RI "void \fBSkyLevel\fR (Pixel *Mean, Pixel *Sigma) const"
.br
.RI "\fIcomputes the mean and sigma of an image using the median (from 10000 random pixels) and loop 3 times.\fR"
.ti -1c
.RI "void \fBSkyLevel\fR (const \fBFrame\fR &\fBFrame\fR, Pixel *Mean, Pixel *Sigma) const"
.br
.ti -1c
.RI "void \fBSurface\fR (const int MeshStep, Image &Result)"
.br
.RI "\fIcomputes a BackImage, subtract it, and returns the result in Result (which should have a 0 average).\fR"
.ti -1c
.RI "void \fBdump\fR () const"
.br
.ti -1c
.RI "int \fBNx\fR () const"
.br
.RI "\fIreturns x size of the image.\fR"
.ti -1c
.RI "int \fBNy\fR () const"
.br
.RI "\fIreturns y size of the image.\fR"
.ti -1c
.RI "Image& \fBoperator=\fR (const Image &Right)"
.br
.ti -1c
.RI "int \fBNPix\fR () const"
.br
.RI "\fIreturns number of pixels.\fR"
.ti -1c
.RI "Image \fBoperator+\fR (const Image &Right) const"
.br
.ti -1c
.RI "Image \fBoperator-\fR (const Image &Right) const"
.br
.ti -1c
.RI "Image \fBoperator *\fR (const Image &Right) const"
.br
.ti -1c
.RI "Image \fBoperator/\fR (const Image &Right) const"
.br
.ti -1c
.RI "void \fBoperator+=\fR (const Image &Right) const"
.br
.ti -1c
.RI "void \fBoperator-=\fR (const Image &Right) const"
.br
.ti -1c
.RI "void \fBoperator *=\fR (const Image &Right) const"
.br
.ti -1c
.RI "void \fBoperator/=\fR (const Image &Right) const"
.br
.ti -1c
.RI "Image \fBoperator+\fR (const double Right) const"
.br
.ti -1c
.RI "Image \fBoperator-\fR (const double Right) const"
.br
.ti -1c
.RI "Image \fBoperator *\fR (const double Right) const"
.br
.ti -1c
.RI "Image \fBoperator/\fR (const double Right) const"
.br
.ti -1c
.RI "void \fBoperator=\fR (const double Right)"
.br
.ti -1c
.RI "void \fBoperator+=\fR (const double Right)"
.br
.ti -1c
.RI "void \fBoperator-=\fR (const double Right)"
.br
.ti -1c
.RI "void \fBoperator *=\fR (const double Right)"
.br
.ti -1c
.RI "void \fBoperator/=\fR (const double Right)"
.br
.ti -1c
.RI "void \fBMultiplyBySquare\fR (const Image &Right)"
.br
.RI "\fImultiply by the square of the image Right.\fR"
.ti -1c
.RI "void \fBHeavyside\fR ()"
.br
.RI "\fIpass the image trough an heaviside function that remove negative pixels.\fR"
.ti -1c
.RI "Pixel \fBInterpolate\fR (const double x, const double y, const int level=3, const bool IsVarianceMap=false) const"
.br
.RI "\fIlinear interpolation routine. I.Interpolate(0.0,0.0) returns I(0,0).\fR"
.ti -1c
.RI "Image \fBGtransfoImage\fR (const \fBGtransfo\fR &g, int nx, int ny, float DefaultVal, const int interpLevel=3, const bool IsVarianceMap=false) const"
.br
.RI "\fIImage resampling. Can handle Variance maps.\fR"
.ti -1c
.RI "Image \fBSubimage\fR (const int x, const int y, const int width, const int height) const"
.br
.RI "\fIextract a subimage.\fR"
.ti -1c
.RI "Image \fBSubimage\fR (const \fBFrame\fR &frame) const"
.br
.RI "\fIextract a subimage.\fR"
.ti -1c
.RI "void \fBSubimageMultiply\fR (const int x, const int y, const int width, const int height, double factor)"
.br
.RI "\fImultiply a subimage by a double.\fR"
.ti -1c
.RI "void \fBSubimageMultiply\fR (const \fBFrame\fR &frame, double factor)"
.br
.RI "\fImultiply a subimage by a double.\fR"
.ti -1c
.RI "Image \fBMask\fR (const int x_Beg, const int y_Beg, const int x_End, const int y_End) const"
.br
.RI "\fIkeep the pixels inside the mask and put the other at 0.0.\fR"
.ti -1c
.RI "void \fBMasking\fR (const \fBFrame\fR &frame, const Pixel &MaskValue=1)"
.br
.RI "\fIput the pixels outside mask to MaskValue.\fR"
.ti -1c
.RI "void \fBDiskMaskIt\fR (const double &xc, const double &yc, const double &radius)"
.br
.RI "\fIput the pixels outside a disk to 1.\fR"
.ti -1c
.RI "void \fBTruncate\fR (const double &xc, const double &yc, const double &radius)"
.br
.RI "\fIput the pixels outside a disk to 0.\fR"
.ti -1c
.RI "void \fBMasking\fR (const int x_Beg, const int y_Beg, const int x_End, const int y_End, const Pixel &MaskValue=1)"
.br
.ti -1c
.RI "void \fBSimplify\fR (double threshold, int above_val=1, int under_val=0)"
.br
.RI "\fIput pixels above threshold to 1 and to 0 otherwise.\fR"
.ti -1c
.RI "void \fBRemoveLonePix\fR (Image &result, int d=1)"
.br
.RI "\fIremove lone bad pixels ie with no bad pixels in a square of 2d+1 x 2d+1.\fR"
.ti -1c
.RI "double \fBSumPixels\fR ()"
.br
.RI "\fIsum pixels values.\fR"
.ti -1c
.RI "double \fBSumSquaredPixels\fR () const"
.br
.RI "\fIsum of the squared pixel values.\fR"
.ti -1c
.RI "void \fBMedianFilter\fR (const int HalfWidth)"
.br
.ti -1c
.RI "Pixel* \fBbegin\fR ()"
.br
.RI "\fIreturns the pointer to the first pixel.\fR"
.ti -1c
.RI "Pixel* \fBbegin\fR () const"
.br
.ti -1c
.RI "Pixel* \fBend\fR ()"
.br
.RI "\fIreturns the pointer to the next to last pixel, as usual for containers.\fR"
.ti -1c
.RI "Pixel* \fBend\fR () const"
.br
.ti -1c
.RI "bool \fBSameSize\fR (const Image &Other) const"
.br
.ti -1c
.RI "int \fBLaplacianFilter\fR (const double &Sigma, const double &Mean, const double &seeing, Image &CosmicImage)"
.br
.RI "\fIBuilds a cosmic map.\fR"
.ti -1c
.RI "void \fBCosmics\fR (const double &Sigma, const double &Mean, const double &seeing, Image &CosmicImage)"
.br
.RI "\fIreturns the final cosmic map(after iterations).\fR"
.ti -1c
.RI "void \fBApplyFun\fR (double(&F)(double))"
.br
.in -1c
.SS Protected Methods

.in +1c
.ti -1c
.RI "void \fBallocate\fR (int Nx, int Ny, int Init=1)"
.br
.ti -1c
.RI "Pixel* \fBget_elem_ref\fR (int i, int j)"
.br
.in -1c
.SS Protected Attributes

.in +1c
.ti -1c
.RI "Pixel* \fBdata\fR"
.br
.ti -1c
.RI "int \fBnx\fR"
.br
.ti -1c
.RI "int \fBny\fR"
.br
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBFitsImageArray\fR"
.br
.ti -1c
.RI "class \fBoperator+\fR"
.br
.ti -1c
.RI "class \fBoperator-\fR"
.br
.ti -1c
.RI "class \fBoperator *\fR"
.br
.ti -1c
.RI "class \fBoperator/\fR"
.br
.ti -1c
.RI "class \fBimage_copy\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Class for the basic manipulation of images.
.PP
The internal representation uses (32 bits) float numbers, designated later as the Pixel type. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int Image::LaplacianFilter (const double & Sigma, const double & Mean, const double & seeing, Image & CosmicImage)
.PP
Builds a cosmic map.
.PP
Cuts (based on the article -> astro-ph/0108003):  -cut_lap : the laplacian operator increases the noise by a factor of  "sqrt(1.25)"
.PP
-cut_f : 2*sigma(med), where sigma(med) is the variance of the sky's median calculated in a box (3*3), here.  (sigma(med) = sigma(sky)*1.22/sqrt(n); n = size of the box)
.PP
-cut_lf : calculated from the article. Factor 2.35 -> to have the seeing in arc sec 

.SH AUTHOR
.PP 
Generated automatically by Doxygen for toads from the source code.