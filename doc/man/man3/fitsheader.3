.TH "FitsHeader" 3 "8 Feb 2004" "toads" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FitsHeader \- Fits files and header keys. 
.SH SYNOPSIS
.br
.PP
\fC#include <fitsimage.h>\fR
.PP
Inherited by \fBFitsImage\fR, and \fBFitsSlice\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "\fBFitsHeader\fR ()"
.br
.ti -1c
.RI "\fBFitsHeader\fR (const string &FileName, const FitsFileMode Mode=RO, bool EmptyFile=false)"
.br
.RI "\fIopens the file, by default in readonly mode.\fR"
.ti -1c
.RI "\fBFitsHeader\fR (const FitsHeader &a_header, const string &NewFileName)"
.br
.RI "\fIopens a new file and copies a old header into it.\fR"
.ti -1c
.RI "\fB~FitsHeader\fR ()"
.br
.ti -1c
.RI "bool \fBIsValid\fR () const"
.br
.RI "\fIreturns if the file could be opened.\fR"
.ti -1c
.RI "string \fBFileName\fR () const"
.br
.RI "\fIaccess routine to the fits file name.\fR"
.ti -1c
.RI "FitsFileMode \fBFileMode\fR () const"
.br
.RI "\fIreturn the file mode (RO or RW).\fR"
.ti -1c
.RI "\fBFitsKey\fR \fBKeyVal\fR (const string &KeyName, const bool Warn=false) const"
.br
.RI "\fIread a key. warns on request.\fR"
.ti -1c
.RI "\fBFitsKey\fR \fBKeyVal_Secure\fR (const string &KeyName) const"
.br
.RI "\fIsame above but test the presence of the key, and exit if not present.\fR"
.ti -1c
.RI "int \fBModKey\fR (const string &KeyName, const int Value, const string Comment="") const"
.br
.RI "\fImodifies an existing key value and comment.\fR"
.ti -1c
.RI "int \fBModKey\fR (const string &KeyName, const double Value, const string Comment="") const"
.br
.RI "\fI-.\fR"
.ti -1c
.RI "int \fBModKey\fR (const string &KeyName, const char *Value, const string Comment="") const"
.br
.RI "\fI-.\fR"
.ti -1c
.RI "int \fBModKey\fR (const string &KeyName, const bool Value, const string Comment="") const"
.br
.RI "\fI-.\fR"
.ti -1c
.RI "int \fBAddKey\fR (const string &KeyName, const char *KeyVal, const string Comment="")"
.br
.RI "\fIadds (at the end of the header) a new key.\fR"
.ti -1c
.RI "int \fBAddKey\fR (const string &KeyName, const double KeyVal, const string Comment="")"
.br
.ti -1c
.RI "int \fBAddKey\fR (const string &KeyName, const int KeyVal, const string Comment="")"
.br
.ti -1c
.RI "int \fBAddKey\fR (const string &KeyName, const bool KeyVal, const string Comment="")"
.br
.ti -1c
.RI "int \fBAddOrModKey\fR (const string &KeyName, const char *Value, const string Comment="")"
.br
.RI "\fImodifies an existing key or adds it if it does not exist yet.\fR"
.ti -1c
.RI "int \fBAddOrModKey\fR (const string &KeyName, const string &Value, const string Comment="")"
.br
.RI "\fImodifies an existing key or adds it if it does not exist yet.\fR"
.ti -1c
.RI "int \fBAddOrModKey\fR (const string &KeyName, const double Value, const string Comment="")"
.br
.RI "\fImodifies an existing key or adds it if it does not exist yet.\fR"
.ti -1c
.RI "int \fBAddOrModKey\fR (const string &KeyName, const int Value, const string Comment="")"
.br
.RI "\fImodifies an existing key or adds it if it does not exist yet.\fR"
.ti -1c
.RI "int \fBAddOrModKey\fR (const string &KeyName, const bool Value, const string Comment="")"
.br
.RI "\fImodifies an existing key or adds it if it does not exist yet.\fR"
.ti -1c
.RI "int \fBKeyMatch\fR (const string &KeyPattern, FitsKeyArray &Array) const"
.br
.RI "\fITo read keys following a pattern.\fR"
.ti -1c
.RI "int \fBModKeyName\fR (const string &OldKeyName, const string &NewKeyName) const"
.br
.RI "\fIchanges the Key itself.\fR"
.ti -1c
.RI "int \fBModKeyComment\fR (const string &KeyName, const string &NewComment) const"
.br
.RI "\fIchanges the comment.\fR"
.ti -1c
.RI "bool \fBHasKey\fR (const string &KeyName, const bool Warn=false) const"
.br
.RI "\fIenables to check the presence of a key. warns on request.\fR"
.ti -1c
.RI "bool \fBHasActualKey\fR (const string &KeyName, const bool Warn=false) const"
.br
.RI "\fIhas a genuine fits key.\fR"
.ti -1c
.RI "int \fBRmKey\fR (const string &KeyName) const"
.br
.RI "\fIdeletes a key.\fR"
.ti -1c
.RI "int \fBNKeys\fR () const"
.br
.RI "\fIreturn the number of keys (without counting the END key).\fR"
.ti -1c
.RI "bool \fBCopyKey\fR (const char *KeyName, FitsHeader &To) const"
.br
.RI "\fIcopy verbatim a key (name, value, comment).\fR"
.ti -1c
.RI "int \fBAddCommentLine\fR (const string &AVeryUsefulComment)"
.br
.RI "\fIadd a COMMENT keyword.\fR"
.ti -1c
.RI "int \fBAddHistoryLine\fR (const string &HistoryStuff)"
.br
.RI "\fIadd a HISTORY keyword.\fR"
.ti -1c
.RI "int \fBFlush\fR ()"
.br
.RI "\fIflush file buffers.\fR"
.ti -1c
.RI "int \fBAddOrModCard\fR (const string &KeyName, const string &Card)"
.br
.RI "\fIadd a whole card, name+value+comment (or modifies an existing one).\fR"
.ti -1c
.RI "void \fBImageSizes\fR (int &Xsize, int &YSize) const"
.br
.ti -1c
.RI "bool \fBSameImageSizes\fR (const FitsHeader &Other) const"
.br
.ti -1c
.RI "\fBPoint\fR \fBImageCenter\fR () const"
.br
.RI "\fIThe geometric center of the image.\fR"
.ti -1c
.RI "bool \fBSameChipFilterInst\fR (const FitsHeader &Other, const bool Warn=true) const"
.br
.RI "\fIchecks that both images refer to the same chip, filter and instrument.\fR"
.ti -1c
.RI "bool \fBSameChipFilter\fR (const FitsHeader &Other, const bool Warn=true) const"
.br
.RI "\fIchecks that both images refer to the same chip and filter.\fR"
.ti -1c
.RI "bool \fBSameChipFilter\fR (const string &OtherFitsName, const bool Warn=true) const"
.br
.ti -1c
.RI "bool \fBSameFilter\fR (const FitsHeader &Other, const bool Warn=true) const"
.br
.RI "\fIchecks that both images refer to the same filter.\fR"
.ti -1c
.RI "bool \fBSameFilter\fR (const string &OtherFitsName, const bool Warn=true) const"
.br
.ti -1c
.RI "bool \fBSameChip\fR (const FitsHeader &Other, const bool Warn=true) const"
.br
.RI "\fIchecks that both images refer to the same chip.\fR"
.ti -1c
.RI "bool \fBSameChip\fR (const string &OtherFitsName, const bool Warn=true) const"
.br
.RI "\fIsame as above, using file name.\fR"
.ti -1c
.RI "VirtualInstrument* \fBTelInst\fR () const"
.br
.ti -1c
.RI "void \fBEnableWrite\fR (const bool YesOrNo)"
.br
.RI "\fIfor a \fBFitsImage\fR opened RW, enables to forbid writing (default behaviour) when destructor is called.\fR"
.ti -1c
.RI "\fBFitsHeader\fR (const FitsHeader &)"
.br
.ti -1c
.RI "void \fBAppend_LowPriority\fR (const FitsHeader &ToAppend)"
.br
.ti -1c
.RI "int \fBMoveHDU\fR (int HowMany=1)"
.br
.ti -1c
.RI "int \fBCopyCHDUTo\fR (FitsHeader &OutHeader)"
.br
.ti -1c
.RI "int \fBCopyDataTo\fR (FitsHeader &OutHeader)"
.br
.ti -1c
.RI "int \fBNHDU\fR () const"
.br
.in -1c
.SS Friends

.in +1c
.ti -1c
.RI "class \fBFitsImageArray\fR"
.br
.ti -1c
.RI "class \fBFitsKey\fR"
.br
.ti -1c
.RI "class \fBFitsImage\fR"
.br
.ti -1c
.RI "class \fBFitsSlice\fR"
.br
.ti -1c
.RI "ostream& \fBoperator<<\fR (ostream &stream, const FitsHeader &Header)"
.br
.RI "\fIenables : 
.PP
.nf
 cout << FitsHeader("my_image.fits"); 
.fi
.\fR"
.in -1c
.SH DETAILED DESCRIPTION
.PP 
Fits files and header keys.
.PP
The FitsHeader class does not deal with the data part of fits files. The actual engine is cfitsio. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS int FitsHeader::AddCommentLine (const string & AVeryUsefulComment)
.PP
add a COMMENT keyword.
.PP
It will be split over multiple  COMMENT lines if longer than 70 characters. 
.SS int FitsHeader::AddHistoryLine (const string & HistoryStuff)
.PP
add a HISTORY keyword.
.PP
It will be split over multiple  HISTORY lines if longer than 70 characters. 
.SS int FitsHeader::AddKey (const string & KeyName, const char * KeyVal, const string Comment = "")
.PP
adds (at the end of the header) a new key.
.PP
Checks before that this key does not exist yet. No comment if Comment is NULL or absent. Value can be int, double, char*, or bool. 
.SS void FitsHeader::EnableWrite (const bool YesOrNo)
.PP
for a \fBFitsImage\fR opened RW, enables to forbid writing (default behaviour) when destructor is called.
.PP
example of use : the flatfielding opens (RW) the flatfielded \fBFitsImage\fR, and  only allow writing on successful flatfielding completion. 
.SS int FitsHeader::KeyMatch (const string & KeyPattern, FitsKeyArray & Array) const
.PP
To read keys following a pattern.
.PP
* matches anything, ? a single character, # successive decimal digits. Array[i]. size() returns the number of matched keys. Array[i].KeyName and {double,string,int}(Array[i]) enable to accees  key names and values 
.SS \fBFitsKey\fR FitsHeader::KeyVal (const string & KeyName, const bool Warn = false) const
.PP
read a key. warns on request.
.PP
use (e.g.) 
.PP
.nf
 double ra = a_header.KeyVal("RA"); 
.fi
 adequate converters are applied for int, double, float, string and bool variables. 
.SS int FitsHeader::ModKey (const string & KeyName, const int Value, const string Comment = "") const
.PP
modifies an existing key value and comment.
.PP
If comment is NULL the comment is unchanged. 

.SH AUTHOR
.PP 
Generated automatically by Doxygen for toads from the source code.