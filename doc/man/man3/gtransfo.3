.TH "Gtransfo" 3 "8 Feb 2004" "toads" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Gtransfo \- a virtual (interface) class for geometric transformations. 
.SH SYNOPSIS
.br
.PP
\fC#include <gtransfo.h>\fR
.PP
Inherited by GtransfoComposition, \fBGtransfoIdentity\fR, GtransfoInverse, \fBGtransfoLin\fR, \fBTanPix2RaDec\fR, and \fBTanRaDec2Pix\fR.
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "virtual void \fBapply\fR (const double Xin, const double Yin, double &Xout, double &Yout) const=0"
.br
.ti -1c
.RI "void \fBapply\fR (const \fBPoint\fR &Pin, \fBPoint\fR &Pout) const"
.br
.RI "\fIapplies the tranfo to Pin and writes into Pout. Is indeed virtual.\fR"
.ti -1c
.RI "\fBPoint\fR \fBapply\fR (const \fBPoint\fR &Pin) const"
.br
.ti -1c
.RI "virtual void \fBdump\fR (ostream &stream=cout) const=0"
.br
.RI "\fIdumps the transfo coefficients to stream.\fR"
.ti -1c
.RI "virtual double \fBfit\fR (const StarMatchList &List, const Gtransfo *PriorTransfo=NULL, const Gtransfo *PosteriorTransfo=NULL)=0"
.br
.RI "\fIfits a transfo to a list of star pairs (p1,p2).\fR"
.ti -1c
.RI "\fBPoint\fR \fBoperator()\fR (const \fBPoint\fR &In) const"
.br
.RI "\fIallows to write MyTransfo(MyStar).\fR"
.ti -1c
.RI "virtual Gtransfo* \fBReduceCompo\fR (const Gtransfo *Right) const"
.br
.RI "\fIallow composition of transformations regardless of their actual types.see \fBGtransfoCompose\fR() for a user callable entry.\fR"
.ti -1c
.RI "virtual Gtransfo* \fBClone\fR () const=0"
.br
.RI "\fIreturns a copy (allocated by new) of the transformation.\fR"
.ti -1c
.RI "virtual double \fBJacobian\fR (const double x, const double y) const"
.br
.RI "\fIreturns the local jacobian.\fR"
.ti -1c
.RI "virtual void \fBDerivative\fR (const \fBPoint\fR &Where, \fBGtransfoLin\fR &Der, const double Step=0.01) const"
.br
.RI "\fIComputes the local Derivative of a transfo. Step is used for numerical derivation.\fR"
.ti -1c
.RI "virtual \fBGtransfoLin\fR \fBLinearApproximation\fR (const \fBPoint\fR &Where, const double step=0.01) const"
.br
.RI "\fIlinear (local) approximation.\fR"
.ti -1c
.RI "virtual void \fBTransformErrors\fR (const \fBPoint\fR &Where, const double *VIn, double *VOut) const"
.br
.RI "\fItransform errors (represented as double[3] in order V(xx),V(yy),Cov(xy)).\fR"
.ti -1c
.RI "virtual Gtransfo* \fBInverseTransfo\fR (const double Precision, const \fBFrame\fR &Region) const"
.br
.RI "\fIreturns an inverse transfo.\fR"
.ti -1c
.RI "virtual Gtransfo* \fBRoughInverse\fR (const \fBFrame\fR &Region) const"
.br
.RI "\fIRough inverse.\fR"
.ti -1c
.RI "virtual int \fBNpar\fR () const"
.br
.RI "\fIreturns the number of parameters (to compute chi2's).\fR"
.ti -1c
.RI "virtual \fB~Gtransfo\fR ()"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
a virtual (interface) class for geometric transformations.
.PP
We implement here One Gtransfo interface class, and actual derived classes. Composition in the usual (mathematical) sense is provided using \fBGtransfoCompose\fR(), and some classes (e.g. \fBGtransfoLin\fR) handle a * operator. Generic inversion by iteration exists, but it is at least 10 times slower than the corresponding "direct transformation". If a transfo has an analytical inverse, then providing InverseTransfo is obviously a very good idea. Before resorting to InverseTransfo, consider using StarMatchList::InverseTransfo(). \fBGtransfoLin::invert\fR() and \fBTanPix2RaDec::invert\fR() exist. The classes also provide derivation and linear approximation. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void Gtransfo::Derivative (const \fBPoint\fR & Where, \fBGtransfoLin\fR & Derivative, const double Step = 0.01) const\fC [virtual]\fR
.PP
Computes the local Derivative of a transfo. Step is used for numerical derivation.
.PP
the Derivative is represented by a \fBGtransfoLin\fR, in which (hopefully), the offset terms are zero. Derivative should  transform a vector of offsets into a vector of offsets. 
.PP
Reimplemented in \fBGtransfoIdentity\fR, \fBGtransfoLin\fR, and \fBGtransfoQuad\fR.
.SS Gtransfo * Gtransfo::InverseTransfo (const double Precision, const \fBFrame\fR & Region) const\fC [virtual]\fR
.PP
returns an inverse transfo.
.PP
Precision and Region refer to the "input" side of this,  and hence to the output side of the returned Gtransfo. 
.PP
Reimplemented in \fBGtransfoLin\fR, \fBGtransfoQuad\fR, \fBTanPix2RaDec\fR, and \fBTanRaDec2Pix\fR.
.SS Gtransfo * Gtransfo::RoughInverse (const \fBFrame\fR & Region) const\fC [virtual]\fR
.PP
Rough inverse.
.PP
Stored by the numerical inverter to guess starting point  for the trials. Just here to enable overloading. 
.PP
Reimplemented in \fBTanPix2RaDec\fR, and \fBTanRaDec2Pix\fR.
.SS double Gtransfo::fit (const StarMatchList & List, const Gtransfo * PriorTransfo = NULL, const Gtransfo * PosteriorTransfo = NULL)\fC [pure virtual]\fR
.PP
fits a transfo to a list of star pairs (p1,p2).
.PP
After the fit this(PriorTransfo(p1)) yields approximately PosteriorTransfo(p2). The returned value is the chi2. 
.PP
Reimplemented in \fBGtransfoIdentity\fR, \fBGtransfoLin\fR, \fBGtransfoLinShift\fR, \fBGtransfoLinRot\fR, \fBGtransfoQuad\fR, \fBGtransfoCub\fR, \fBTanPix2RaDec\fR, and \fBTanRaDec2Pix\fR.

.SH AUTHOR
.PP 
Generated automatically by Doxygen for toads from the source code.