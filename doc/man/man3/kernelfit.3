.TH "KernelFit" 3 "8 Feb 2004" "toads" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KernelFit \- \fBKernel\fR fitting by least squares. 
.SH SYNOPSIS
.br
.PP
\fC#include <kernelfit.h>\fR
.PP
.SS Public Methods

.in +1c
.ti -1c
.RI "int \fBHKernelSizeX\fR ()"
.br
.ti -1c
.RI "int \fBHKernelSizeY\fR ()"
.br
.ti -1c
.RI "int \fBKernIndex\fR (int iKernel, int iSpatial) const"
.br
.ti -1c
.RI "int \fBBackIndex\fR (int ib) const"
.br
.ti -1c
.RI "double \fBBackValue\fR (const double &x, const double &y) const"
.br
.ti -1c
.RI "void \fBDeleteConvolvedBest\fR ()"
.br
.ti -1c
.RI "\fBKernelFit\fR ()"
.br
.ti -1c
.RI "\fB~KernelFit\fR ()"
.br
.ti -1c
.RI "void \fBKernelsFill\fR ()"
.br
.ti -1c
.RI "void \fBAllocateConvolvedStamps\fR ()"
.br
.ti -1c
.RI "void \fBDeallocateConvolvedStamps\fR ()"
.br
.ti -1c
.RI "void \fBComputeMAndB\fR ()"
.br
.RI "\fIsums least square matrix and vector for all stamps.\fR"
.ti -1c
.RI "void \fBOneStampMAndB\fR (const \fBStamp\fR &Astamp, double *StampM, double *StampB)"
.br
.RI "\fIcomputes least square matrix and vector for one stamp.\fR"
.ti -1c
.RI "void \fBSubtractStampFromMAndB\fR (\fBStamp\fR &AStamp)"
.br
.RI "\fIsubtract a stamp of the least square matrix and vector.\fR"
.ti -1c
.RI "int \fBSolve\fR ()"
.br
.RI "\fIactually solves the system by calling linear algebra efficient routines.\fR"
.ti -1c
.RI "double \fBStampChi2\fR (\fBStamp\fR &stamp, double VSky, double InvGain)"
.br
.ti -1c
.RI "int \fBNStampsUsed\fR () const"
.br
.ti -1c
.RI "void \fBFilterStamps\fR ()"
.br
.ti -1c
.RI "int \fBDoTheFit\fR (const BaseStarList &List, double &BestSeeing, double &WorstSeeing)"
.br
.RI "\fIfinal wrapper that calls various routines to fill matrix and vector, and then solve.\fR"
.ti -1c
.RI "int \fBDoIt\fR (const BaseStarList &List, double &BestSeeing, double &WorstSeeing)"
.br
.RI "\fIdoes the kernel fit (DoTheFit) and the convolution (BestImageConvolve).\fR"
.ti -1c
.RI "void \fBKernCompute\fR (\fBKernel\fR &Result, const double X, const double Y) const"
.br
.ti -1c
.RI "void \fBBestImageConvolve\fR (int UpdateKernStep=100)"
.br
.RI "\fIconvolves the best image with the current kernel (Usually set by DoTheFit).\fR"
.ti -1c
.RI "\fBImage\fR* \fBVarianceConvolve\fR (const \fBImage\fR &Source, int UpdateKern=100)"
.br
.in -1c
.SS Public Attributes

.in +1c
.ti -1c
.RI "const \fBImage\fR* \fBBestImage\fR"
.br
.RI "\fIpointer to 'best' image (smaller seeing).\fR"
.ti -1c
.RI "const \fBImage\fR* \fBWorstImage\fR"
.br
.RI "\fIpointer to 'worst' image (larger seeing).\fR"
.ti -1c
.RI "double \fBBestImageBack\fR"
.br
.RI "\fIthe value of the sky of the best image.\fR"
.ti -1c
.RI "double \fBWorstImageBack\fR"
.br
.RI "\fIthe value of the sky of the worst image.\fR"
.ti -1c
.RI "double \fBSkyVarianceWorstImage\fR"
.br
.RI "\fIthe value of the sky variance of WorstImage.\fR"
.ti -1c
.RI "double \fBWorstImageGain\fR"
.br
.RI "\fIthe gain of WorstImage.\fR"
.ti -1c
.RI "double \fBKernAtCenterSum\fR"
.br
.RI "\fIthe kernel integral at the image center (photometric ratio).\fR"
.ti -1c
.RI "vector<\fBKernel\fR> \fBKernels\fR"
.br
.ti -1c
.RI "\fBStampList\fR* \fBBestImageStamps\fR"
.br
.RI "\fIthe base used to build the 'best' kernel */ the list of stamps in the 'best' image.\fR"
.ti -1c
.RI "\fBImage\fR* \fBConvolvedBest\fR"
.br
.RI "\fIa pointer to the 'best' image convolved with the solution.\fR"
.ti -1c
.RI "\fBDImage\fR* \fBconvolutions\fR"
.br
.ti -1c
.RI "\fBDImage\fR* \fBbackStamps\fR"
.br
.ti -1c
.RI "OptParams \fBoptParams\fR"
.br
.ti -1c
.RI "int \fBmSize\fR"
.br
.ti -1c
.RI "int \fBbackStart\fR"
.br
.ti -1c
.RI "double* \fBm\fR"
.br
.ti -1c
.RI "double* \fBb\fR"
.br
.RI "\fIthe least-squares matrix (the second derivative of chi2 w.r.t fitted parameters */;.\fR"
.ti -1c
.RI "double* \fBsolution\fR"
.br
.RI "\fIthe normal equations (i.e. grad(chi2) = 0) right hand side */.\fR"
.ti -1c
.RI "double \fBchi2\fR"
.br
.in -1c
.SH DETAILED DESCRIPTION
.PP 
\fBKernel\fR fitting by least squares.
.PP
Implementation of Ch. Alard's method for fitting (slowly variable)  convolution kernels. see astro-ph 9903111 & astro-ph 9712287  (where most of the equations of page 2 are wrong). Main differences with the "isis" code provided by Alard himself: 
.TP
 if the integral of the kernel is requested to be constant over the image, we use Lagrange multipliers instead of something I could not understand. (paper from 97 page 3 first column). 
.TP
 for the detection of outliers, we compute the chi2 of all stamps,  apply median filtering, refit, and iterate until stabilization of the number of stamps. This is in fact fairly fast because we have routines to  add or remove one stamp from the fit. 
.PP
.SH MEMBER FUNCTION DOCUMENTATION
.PP 
.SS void KernelFit::BestImageConvolve (int UpdateKern = 100)
.PP
convolves the best image with the current kernel (Usually set by DoTheFit).
.PP
The UpdateKern parameter is the pixel range over which the kernel will not be updated. The concolved image is to be found in ConvolvedBest. 
.SS int KernelFit::DoTheFit (const BaseStarList & List, double & BestSeeing, double & WorstSeeing)
.PP
final wrapper that calls various routines to fill matrix and vector, and then solve.
.PP
Before entering here, 'this' should have the BestImage and WorstImage fields assigned. The various sizes of the stamps involved in kernel fit are computed by OptParams::OptimizeSizes(). There is no way yet to by-pass it and setup the fit conditions by yourself (it would be simple to implement). The returned value is 0 if the kernel fit failed (and hence 'this' contains no viable kernel). 
.PP
\fBParameters: \fR
.in +1c
.TP
\fB\fIList\fR\fR
contains the stars elligible to fit the kernel. 
.SH MEMBER DATA DOCUMENTATION
.PP 
.SS \fBStampList\fR * KernelFit::BestImageStamps
.PP
the base used to build the 'best' kernel */ the list of stamps in the 'best' image.
.PP
/* 
.SS double * KernelFit::b
.PP
the least-squares matrix (the second derivative of chi2 w.r.t fitted parameters */;.
.PP
/* 
.SS double * KernelFit::solution
.PP
the normal equations (i.e. grad(chi2) = 0) right hand side */.
.PP
/* 

.SH AUTHOR
.PP 
Generated automatically by Doxygen for toads from the source code.