\subsection{Header Standardization}\label{fitstoad_long}
 We explain here how headers are presented with a uniform interface to the other parts of the code.

\subsubsection{Implementation description and usage of fitstoad}\label{fitstoad_implementation}


{\bf fitstoad.cc} is the main file for presenting Fits headers in a uniform fashion to the rest of the code.

Seb implemented a first version of these functionnalities. Although it did the job, it was hard to scale it up. It also missed a default behavior, functionnality per functionnality.

The (2nd generation) choosen implementation is the following: We have a Virtual\-Instrument class that interfaces the code to actual instrument classes. This Virtual\-Instrument class has about 20 (virtual) routines, most of them being the translation of the famous TOAD keys. I added a few missing routines (which you could locate as big switches in the \char`\"{}old\char`\"{} code, in usnoutils.cc and superflat.cc). {\bf fitstoad.cc} contains the default implementation (Virtual\-Instrument) and the interface to external world. To make the things really tight, I even did not put the Virtual\-Instrument class in fitstoad.h . I realize that this is arguable, but enforces a rigorous design. Then, the actual instruments are in a separate directory, and if you remove a file from this directory, your code still compiles and an instrument has disappeared. The consequence is that adding an instrument involves the coding of one file, and NO MODIFICATION elsewhere. This was the baseline of the new design. We also allow to use all C++ resources about class derivation you may want to use. For example, if some changes in the DAQ of a telescope involve minor changes, you should implement them as derived class of something that already worked. Implement the derived class in the same file as the base class you want to derive it from, in order to control the ordering in which the main \char`\"{}type\char`\"{} switch tries to match a given header to the provided classes. For most of your actual headers, the default implementation  (The Virtual\-Instrument routines) will provide the right behavior. I coded a test routine called if your require the pseudo key TOADALL. (header -k TOADALL your\_\-fitsfile invokes it)

The provided instruments are in the directory ../telinst/  .cc in ../telinst are the files included in {\bf fitstoad.cc}. Adding files there does not require modifying the Makefile (or mgr/requirements file). Some code is automatically generated from parsing these files (using grep and sed) and generates alltelinst.cc and alltelinst.h The \char`\"{}code generator\char`\"{} is a makefile section located at the end of {\bf fitstoad.cc}, and extracted by the main Makefile.

This code generator collects the Acceptor routines, and put all them in an array (Acceptors\-Array). Sniff\-Tel\-Inst tries all components of the array and keeps the first match. An Unknown class (placed at the end of the array) ensures that there will be a successful match.  You have a single way to control the ordering of trials for related instruments. For classes in the same file, \char`\"{}Acceptor\char`\"{} routines will be called from last to first. If you derive an existing class, you should put the derived class after the base class, in the SAME file.

\subsubsection{Coding a new \char`\"{}tel/inst\char`\"{}}\label{newtelinst}
 Here are the guidelines for the actual implementation of a new tel/inst. You may use already coded stuff as an example. There are several related instruments coded using derived classes  in intwfc.cc. you should first try a \char`\"{}header -k TOADALL $<$samplefile.fits$>$\char`\"{} to see what does not work for your case(s) in the default implementation.

To code $<$yourtelinst$>$.cc:\begin{CompactItemize}
\item 
the best thing to do is to copy/paste one file that exists.\item 
in general you do not need include files: your code will be included in {\bf fitstoad.cc} after the utility routines you may need. If you refer to other toads parts (such as wcsutils), include the correct include file.\end{CompactItemize}
\begin{CompactItemize}
\item 
your class should derive (directly or not) from Virtual\-Instrument.\item 
In most of the cases, your class will contain an Acceptor routine, i.e. the routine that indicates that a given header belongs to the class you are coding. In this likely case, put a comment containing  TYPE\_\-SELECTOR on the same line as the class declaration. See already coded routines for the signature of Acceptor. DO NOT USE \char`\"{}TOAD$\ast$\char`\"{} keys IN THE CODE OF THE Acceptor ROUTINE. You may easily figure out why!\end{CompactItemize}
\begin{CompactItemize}
\item 
you have to define the 3 name routines (Tel\-Inst\-Name, Tel\-Name, Inst\-Name)\item 
you have to define the toadkey translators for the keys which do not work by default. Use extensively the SIMPLE\_\-TRANSLATOR and RETURN\_\-A\_\-VALUE macros. They protect you from trivial bugs, and will ease any future changes, if needed.\end{CompactItemize}
Not all TOAD keys are necessary for every task. TOADPIXS is important: return something correct. TOADEXPO is easy to map, do it if default does not apply. There are routines provided to decode dates.

\subsubsection{Routines used  for flatfielding}\label{functions_for_flatfielding}


There are 4 routines related to flafielding: \footnotesize\begin{verbatim}  Frame OverscanRegion(const FitsHeader &Head, const int Iamp) const;
  Frame TotalIlluRegion(const FitsHeader &Head) const;
  Frame IlluRegion(const FitsHeader &Head, const int Iamp) const;
  Frame AmpRegion(const FitsHeader &Head, const int Iamp) const;\end{verbatim}\normalsize 


Do not bother with those if you do not plan to flatfield with TOADS.

\subsubsection{Guessing a rough WCS.}\label{guess_wcs}


The Guess\-Lin\-WCS is used by matchusno, to figure which patch of the  usno catalog to use. If you have Db\-Images. try \char`\"{}matchusno -n $<$your\_\-db\_\-image$>$\char`\"{} to see if it works by default. The default WCS just assumes north-up east-left and that RA and DEC refer to the center of the image (they are read via Ra\-Dec2000, which cooks up values from TOADRASC, TOADDECL and TOADEQUI)

\subsubsection{Testing how it works}\label{test_fitstoad}
 To test your implementation use : header -k TOADALL $<$your\_\-fitsfile$>$

\subsubsection{Type testers:}\label{type_tester}


If you want to generate a \char`\"{}type tester\char`\"{} for your class, because there are places in the code where you would like to put some instrument dependent code, you have to place a comment containing TYPE\_\-TESTER on the line that declares your class (as for  TYPE\_\-SELECTOR)

You then have a routine \footnotesize\begin{verbatim}bool IsOfKind<YourBeautifulInstrument>(const FitsHeader &) \end{verbatim}\normalsize 
 which is generated. (instanciated in the C++ jargon)

you may now use it (with include \char`\"{}fitstoad.h\char`\"{}): \footnotesize\begin{verbatim}  if (IsOfKind<YourBeautifulInstrument>(head))
    {
       .... // specific processing
    }\end{verbatim}\normalsize 


You should however try not to resort to such a scheme, because it is breaking the instrument abstraction. This may just mean that Virtual Instrument misses  one functionnality, that you may consider addding.

Pierre.

