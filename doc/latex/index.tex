 TOols for Analysis and Detection of Supernovae

$\backslash$authors Pierre Astier {\tt pierre.astier@in2p3.fr}\par
 Sebastien Fabbro {\tt sfabbro@in2p3.fr}\par
 Delphine Hardin {\tt hardin@snova1.in2p3.fr}\par
 Julien Raux {\tt julien.raux@in2p3.fr}\par
 Kyan Schahmaneche {\tt kyan@lpnhep.in2p3.fr}\par
 All these people belong to the {\tt FROGS} \par


\begin{Desc}
\item[{\bf Date: }]\par
$\backslash$today

\end{Desc}
\begin{Desc}
\item[{\bf Attention: }]\par
This document is the user manual and reference manual of TOADS.  It will then never be up to date. It is generated using \char`\"{}doxygen\char`\"{}.\par
 It is far from being complete.

\end{Desc}
The structure of the document is:

\begin{CompactItemize}
 \item 
 {\bf Introduction} {\rm (p.\,\pageref{introduction})} \item 
 {\bf Images} {\rm (p.\,\pageref{images})} \item 
 {\bf Images I/O} {\rm (p.\,\pageref{imageio})} \item 
 {\bf Geometrical Transformations} {\rm (p.\,\pageref{geomtransfo})} \item 
 {\bf Stars and lists of stars} {\rm (p.\,\pageref{starlists})} \item 
 {\bf Database} {\rm (p.\,\pageref{database})} \item 
 {\bf Various image types} {\rm (p.\,\pageref{reducedimage})} \item 
 {\bf Standardization of headers.} {\rm (p.\,\pageref{fitstoad})} \item 
 {\bf Getting Started.} {\rm (p.\,\pageref{gettingstarted})} \begin{CompactItemize}
 \item 
 {\bf Putting images in the data base.} {\rm (p.\,\pageref{installing_images})}  \item 
 {\bf Inspecting Database.} {\rm (p.\,\pageref{inspecting_database})}  \item 
 {\bf Making a catalog.} {\rm (p.\,\pageref{cataloging})} \end{CompactItemize}
 \item 
 {\bf Running a subtraction.} {\rm (p.\,\pageref{subtracting})} \item 
 {\bf Producing a lightcurve} {\rm (p.\,\pageref{lightcurve})} \end{CompactItemize}


\subsection{Introduction}\label{introduction}


TOADS aims at providing a framework for astronomy image analysis, with an emphasis on image subtraction and differential photometry of varying objects. At variance with most of the codes developped in the astronomy community, it is NOT intended to provide ready-to-use tools. There is in fact very little chance that your problem is already solved in TOADS, unless you are doing the same thing as we are. Our purpose is more to provide a convenient toolbox, in which you will have to collect components and write your own code. If C++ evocates nothing to you, TOADS is likely to be the bad choice.

Our second bias is that there is nothing interactive (yet?) in TOADS, because it was developped originally to carry out supernova detections by image subtraction, while the observers are asleep. And it actually does that, and more things as time goes on.

We have tried to separate as much as possible the various concepts involved in image analysis, such as images, geometrical transformations, lists of stars.

\subsection{Images}\label{images}
 the images are implemented in memory as arrays of float, with  pixel addressing (starting at 0) and most of the algebra  operators are implemented. see {\bf Image} {\rm (p.\,\pageref{class_image})}.

\subsection{Images I/O}\label{imageio}
 The {\bf Image} {\rm (p.\,\pageref{class_image})} 's are read/written using cfitsio. The access to header keys are in the {\bf Fits\-Header} {\rm (p.\,\pageref{class_fitsheader})} class, the {\bf Fits\-Image} {\rm (p.\,\pageref{class_fitsimage})} class assembles a {\bf Fits\-Header} {\rm (p.\,\pageref{class_fitsheader})} and an {\bf Image} {\rm (p.\,\pageref{class_image})}. read and write (if applicable) are associated with constructors/destructor. There is no check in the provided code  that you are altering the contents associated with a file opened read-only, i.e. that you are modifying data in memeory and only in memory, without any effect on disk.

There are 2 auxialiary classes for sets of fits images: {\bf Fits\-Set} {\rm (p.\,\pageref{class_fitsset})}, which checks that the images where taken with the same filters and instrument, and corresponds to the same cgip, and {\bf Fits\-Parallel\-Slices} {\rm (p.\,\pageref{class_fitsparallelslices})}, which is intended to  allow processing a large number of images in a very parallel way, ass needed for e.g. superflat computation or image stacking.

\subsection{Geometrical Transformations}\label{geomtransfo}


The concept of geometrical transformation mainly refers to applications that transform a point of the plane into a point of the plane. We then have routines that transform images and  lists of stars.

The abstract concept was implemented as an abstract class : {\bf Gtransfo} {\rm (p.\,\pageref{class_gtransfo})}. The actual implementations that already exist are polynomial transformations of inscreasing degree: {\bf Gtransfo\-Lin} {\rm (p.\,\pageref{class_gtransfolin})}, {\bf Gtransfo\-Quad} {\rm (p.\,\pageref{class_gtransfoquad})}, {\bf Gtransfo\-Cub} {\rm (p.\,\pageref{class_gtransfocub})}, rotations and translations are defined from {\bf Gtransfo\-Lin} {\rm (p.\,\pageref{class_gtransfolin})}, and  the do-nothing {\bf Gtransfo\-Identity} {\rm (p.\,\pageref{class_gtransfoidentity})}, which is handy in several cases. On top of providing the transformation, the classes should provide a fitting routine, which uses a collection of pairs of points to be fitted to the model the class implements. These list are called Star\-Match\-List and can be constructed in various ways. Directly from starlists (see below), you can invoque the guessing routines in {\bf listmatch.h}. There are also higher level wrapping routines  in {\bf imagematch.h}

The matchusno command matches a {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} to the USNO catalog and writes the resulting WCS in the image header. The model we use is close to WCS standards, but not exactly identical. This is why we also have the \char`\"{}astrom\char`\"{} command line utility to translate image coordinates to sky and  vice-versa using this WCS. We are studying the feasibility of using the actual latest fits standards.

\subsection{Stars and lists of stars}\label{starlists}
 A few star formats are already defined in the code. The {\bf Base\-Star} {\rm (p.\,\pageref{class_basestar})} only contains  coordinates and flux, and is mainly used for geometrical matching. {\bf SEStar} {\rm (p.\,\pageref{class_sestar})} is the  star that we extract from SEXtractor, and it derives from {\bf Base\-Star} {\rm (p.\,\pageref{class_basestar})}. All star kinds have a {\bf Star\-List} {\rm (p.\,\pageref{class_starlist})} defined, which uses the STL list container. They are coded in such a way that lists of derived objects can be casted to lists of a base type. This is what the {\bf SE2Base}() {\rm (p.\,\pageref{sestar_h_a10})} routines do.

\subsection{Database}\label{database}
 We have implemented a very crude file database, which is in fact not  a database. An entry is this database, is a {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})}, which is an image in an abstract sense: a {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} contains a raw image, a flat image, a dead image, a fringe image,  a catalog, and other goodies. What the Database does is mainly to provide  where the datafiles are, provided a name (the {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} name) and a function. The database code searches the requested information in directories  which are to be provided by the user. See {\bf Data\-Base} {\rm (p.\,\pageref{database_page})} for details.

\subsection{Various image types}\label{reducedimage}
 The successive steps for {\bf Image} {\rm (p.\,\pageref{class_image})} subtraction are handled through a set of classes derived from {\bf Reduced\-Image} {\rm (p.\,\pageref{class_reducedimage})}: {\bf Transformed\-Image} {\rm (p.\,\pageref{class_transformedimage})}, {\bf Image\-Sum} {\rm (p.\,\pageref{class_imagesum})}, {\bf Image\-Subtraction} {\rm (p.\,\pageref{class_imagesubtraction})}. They all follow the same pattern as {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} (they in fact inherit from it). When you construct such images (you transform, sum, subtract), {\bf Reduced\-Image} {\rm (p.\,\pageref{class_reducedimage})}'s are created and written to disk. The physical location is the one tagged by \char`\"{}here\char`\"{} in the $\backslash$red dbconfig. The actual value is usually the local directory (As in {\bf Example of Db configuration file} {\rm (p.\,\pageref{dbconfig_example})}), from which you actually run your executable (e.g. newmake\_\-sub).

\subsection{Getting Started.}\label{gettingstarted}


To obtain the code, you have to go through one of the authors. Installing the code and prerequisite is detailed in the README. before running anything that uses {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})}'s, you have to provide a db config file (see {\bf The data base configuration file.} {\rm (p.\,\pageref{dbconfig})}). make\_\-catalog and image subtractions use datacards, which are located with TOADCARDS, which has to be defined as the directory that contains those datacards (distributed with the source code).

\subsubsection{Putting images in the data base.}\label{installing_images}
 You have to use install\_\-image for that. If you want to install the image 604053o02.fits in the directory /snovad24/cfht01B, you just have to do: \footnotesize\begin{verbatim} install_image /snovad24/cfht01 604053o02.fits\end{verbatim}\normalsize 
 You can install a bunch of images at a time. The {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} you just created will be named 604053o02. It now has one field: the \char`\"{}raw\char`\"{} image. If the fits image you want to enter is already flatfielded, you should invoke install\_\-image with the option \char`\"{}-cal\char`\"{}. In this case, the assigned field of your {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})} is the \char`\"{}calibrated\char`\"{} image. Notice that the fits file is not copied but linked. The routine that assigns this link does it best to avoid absolute pathes in the links, in order to allow you to move a whole directory tree if needed.

Then for the database to find the image back, you have to put the path /snovad24/cfht01 in your {\bf The data base configuration file.} {\rm (p.\,\pageref{dbconfig})}. When you are done, you can check that the image is actually located by the database system:

\subsubsection{Inspecting Database.}\label{inspecting_database}
 The command dbls enables you to see what the database currently contains. dbls -h issues a small help. dbls is far less sophisticated than ls. \char`\"{}dbls 604053o02\char`\"{} should output 604053o02, and \char`\"{}dbls -raw 604053o02\char`\"{} should output /snovad24/cfht01/604053o02/raw.fits. This is the file name that you will get in your code when you will want to access the \char`\"{}raw\char`\"{} field of your {\bf Db\-Image} {\rm (p.\,\pageref{class_dbimage})}. We have a \char`\"{}header\char`\"{} command that enables you to dump a fits header or  subparts of it, and it is connected to the database: \footnotesize\begin{verbatim}> header -k RA -k DEC /snovad24/cfht01B/604053o02/calibrated.fits
/snovad24/cfht01B/604053o02/calibrated.fits 22:17:50.59 0:10:26.3
> header -k RA -k DEC -cal 604053o02
604053o02 22:17:50.59 0:10:26.3 \end{verbatim}\normalsize 


\subsection{Standardization of headers.}\label{fitstoad}
 Sebastien Fabbro has designed a scheme that enables to present the fits headers in a telescope/instrument independent fashion to the code. This is based  on active routines, rather than overwritting actual headers. This goes through a virtual instrument system, that performs the right translations and/or computations for a specific telescope instrument. There is a default implementation that may do correctly for a telescope/instrument still  unknown to TOADS. You may test it through: \footnotesize\begin{verbatim}header -k TOADALL your_image.fits\end{verbatim}\normalsize 
 To see how well (or badly) it works for your specific case. If it does  not work properly, you have to go through {\bf Coding a new \char`\"{}tel/inst\char`\"{}} {\rm (p.\,\pageref{newtelinst})}.

\subsubsection{Making a catalog.}\label{cataloging}
 Most of the useful code of TOADS requires image catalogs. You just have to run make\_\-catalog to get it computed and written to disk.

\subsection{Running a subtraction.}\label{subtracting}
 You first have to create a \char`\"{}subfile\char`\"{} (see {\bf Syntax of the \char`\"{}subfile\char`\"{}} {\rm (p.\,\pageref{subfile})}),  and then you just run newmake\_\-sub. You may log the output, which contains very useful informations when things go wrong.

\subsection{Producing a lightcurve}\label{lightcurve}
 To build a lightcurve for a supernova we need to know where is the  supernova and on which night it has been observed. You then need  to produce a \char`\"{}lightfile\char`\"{} (see {\bf Syntax of the \char`\"{}lightfile\char`\"{}} {\rm (p.\,\pageref{lightfile})}) Find a directory with a lot of space. Then type

make\_\-lightcurve $<$myfile$>$

and go for coffee. See lcresults for lightcurve results.

