<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Header Standardization</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.6 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindexRef" doxygen="_cgi:http://ici.la.bas/toto/tata/search.cgi" href="http://ici.la.bas/toto/tata/search.cgi">Search</a> &nbsp; </center>
<hr><a name="fitstoad_long"><h2>Header Standardization</h2></a>
 We explain here how headers are presented with a uniform interface to the other parts of the code.
<p>
<a name="fitstoad_implementation"><h3>Implementation description and usage of fitstoad</h3></a>

<p>
<a class="el" href="fitstoad_cc.html">fitstoad.cc</a> is the main file for presenting Fits headers in a uniform fashion to the rest of the code.
<p>
Seb implemented a first version of these functionnalities. Although it did the job, it was hard to scale it up. It also missed a default behavior, functionnality per functionnality.
<p>
The (2nd generation) choosen implementation is the following: We have a VirtualInstrument class that interfaces the code to actual instrument classes. This VirtualInstrument class has about 20 (virtual) routines, most of them being the translation of the famous TOAD keys. I added a few missing routines (which you could locate as big switches in the "old" code, in usnoutils.cc and superflat.cc). <a class="el" href="fitstoad_cc.html">fitstoad.cc</a> contains the default implementation (VirtualInstrument) and the interface to external world. To make the things really tight, I even did not put the VirtualInstrument class in fitstoad.h . I realize that this is arguable, but enforces a rigorous design. Then, the actual instruments are in a separate directory, and if you remove a file from this directory, your code still compiles and an instrument has disappeared. The consequence is that adding an instrument involves the coding of one file, and NO MODIFICATION elsewhere. This was the baseline of the new design. We also allow to use all C++ resources about class derivation you may want to use. For example, if some changes in the DAQ of a telescope involve minor changes, you should implement them as derived class of something that already worked. Implement the derived class in the same file as the base class you want to derive it from, in order to control the ordering in which the main "type" switch tries to match a given header to the provided classes. For most of your actual headers, the default implementation  (The VirtualInstrument routines) will provide the right behavior. I coded a test routine called if your require the pseudo key TOADALL. (header -k TOADALL your_fitsfile invokes it)
<p>
The provided instruments are in the directory ../telinst/  .cc in ../telinst are the files included in <a class="el" href="fitstoad_cc.html">fitstoad.cc</a>. Adding files there does not require modifying the Makefile (or mgr/requirements file). Some code is automatically generated from parsing these files (using grep and sed) and generates alltelinst.cc and alltelinst.h The "code generator" is a makefile section located at the end of <a class="el" href="fitstoad_cc.html">fitstoad.cc</a>, and extracted by the main Makefile.
<p>
This code generator collects the Acceptor routines, and put all them in an array (AcceptorsArray). SniffTelInst tries all components of the array and keeps the first match. An Unknown class (placed at the end of the array) ensures that there will be a successful match.  You have a single way to control the ordering of trials for related instruments. For classes in the same file, "Acceptor" routines will be called from last to first. If you derive an existing class, you should put the derived class after the base class, in the SAME file.
<p>
<a name="newtelinst"><h3>Coding a new "tel/inst"</h3></a>
 Here are the guidelines for the actual implementation of a new tel/inst. You may use already coded stuff as an example. There are several related instruments coded using derived classes  in intwfc.cc. you should first try a "header -k TOADALL &lt;samplefile.fits&gt;" to see what does not work for your case(s) in the default implementation.
<p>
To code &lt;yourtelinst&gt;.cc:<ul>
<li>the best thing to do is to copy/paste one file that exists.<li>in general you do not need include files: your code will be included in <a class="el" href="fitstoad_cc.html">fitstoad.cc</a> after the utility routines you may need. If you refer to other toads parts (such as wcsutils), include the correct include file.</ul>
<ul>
<li>your class should derive (directly or not) from VirtualInstrument.<li>In most of the cases, your class will contain an Acceptor routine, i.e. the routine that indicates that a given header belongs to the class you are coding. In this likely case, put a comment containing  TYPE_SELECTOR on the same line as the class declaration. See already coded routines for the signature of Acceptor. DO NOT USE "TOAD*" keys IN THE CODE OF THE Acceptor ROUTINE. You may easily figure out why!</ul>
<ul>
<li>you have to define the 3 name routines (TelInstName, TelName, InstName)<li>you have to define the toadkey translators for the keys which do not work by default. Use extensively the SIMPLE_TRANSLATOR and RETURN_A_VALUE macros. They protect you from trivial bugs, and will ease any future changes, if needed.</ul>
Not all TOAD keys are necessary for every task. TOADPIXS is important: return something correct. TOADEXPO is easy to map, do it if default does not apply. There are routines provided to decode dates.
<p>
<a name="functions_for_flatfielding"><h3>Routines used  for flatfielding</h3></a>

<p>
There are 4 routines related to flafielding: <div class="fragment"><pre>  <a class="code" href="class_frame.html">Frame</a> <a class="code" href="fitstoad_cc.html#a26">OverscanRegion</a>(<font class="keyword">const</font> <a class="code" href="class_fitsheader.html">FitsHeader</a> &amp;Head, <font class="keyword">const</font> <font class="keywordtype">int</font> Iamp) <font class="keyword">const</font>;
  <a class="code" href="class_frame.html">Frame</a> <a class="code" href="fitstoad_cc.html#a28">TotalIlluRegion</a>(<font class="keyword">const</font> <a class="code" href="class_fitsheader.html">FitsHeader</a> &amp;Head) <font class="keyword">const</font>;
  <a class="code" href="class_frame.html">Frame</a> <a class="code" href="fitstoad_cc.html#a27">IlluRegion</a>(<font class="keyword">const</font> <a class="code" href="class_fitsheader.html">FitsHeader</a> &amp;Head, <font class="keyword">const</font> <font class="keywordtype">int</font> Iamp) <font class="keyword">const</font>;
  <a class="code" href="class_frame.html">Frame</a> <a class="code" href="fitstoad_cc.html#a29">AmpRegion</a>(<font class="keyword">const</font> <a class="code" href="class_fitsheader.html">FitsHeader</a> &amp;Head, <font class="keyword">const</font> <font class="keywordtype">int</font> Iamp) <font class="keyword">const</font>;</pre></div>
<p>
Do not bother with those if you do not plan to flatfield with TOADS.
<p>
<a name="guess_wcs"><h3>Guessing a rough WCS.</h3></a>

<p>
The GuessLinWCS is used by matchusno, to figure which patch of the  usno catalog to use. If you have DbImages. try "matchusno -n &lt;your_db_image&gt;" to see if it works by default. The default WCS just assumes north-up east-left and that RA and DEC refer to the center of the image (they are read via RaDec2000, which cooks up values from TOADRASC, TOADDECL and TOADEQUI)
<p>
<a name="test_fitstoad"><h3>Testing how it works</h3></a>
 To test your implementation use : header -k TOADALL &lt;your_fitsfile&gt;
<p>
<a name="type_tester"><h3>Type testers:</h3></a>

<p>
If you want to generate a "type tester" for your class, because there are places in the code where you would like to put some instrument dependent code, you have to place a comment containing TYPE_TESTER on the line that declares your class (as for  TYPE_SELECTOR)
<p>
You then have a routine <div class="fragment"><pre><font class="keywordtype">bool</font> IsOfKind&lt;YourBeautifulInstrument&gt;(<font class="keyword">const</font> <a class="code" href="class_fitsheader.html">FitsHeader</a> &amp;) </pre></div> which is generated. (instanciated in the C++ jargon)
<p>
you may now use it (with include "fitstoad.h"): <div class="fragment"><pre>  <font class="keywordflow">if</font> (IsOfKind&lt;YourBeautifulInstrument&gt;(head))
    {
       .... <font class="comment">// specific processing</font>
    }</pre></div>
<p>
You should however try not to resort to such a scheme, because it is breaking the instrument abstraction. This may just mean that Virtual Instrument misses  one functionnality, that you may consider addding.
<p>
Pierre.
<p>
<hr><address><small>Generated at Sun Feb 8 18:22:50 2004 for toads by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.6 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
